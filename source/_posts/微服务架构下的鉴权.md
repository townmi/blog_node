---
title: 微服务架构下的鉴权
date: 2020-06-04 03:53:02
tags:
- JS
categories:
- 前端
---

### 微服务架构下的鉴权
从单体应用架构到分布式应用架构再到微服务架构，应用的安全访问在不断的经受考验。为了适应架构的变化、需求的变化，身份认证与鉴权方案也在不断的变革。面对数十个甚至上百个微服务之间的调用，如何保证高效安全的身份认证？面对外部的服务访问，该如何提供细粒度的鉴权方案？本文将会为大家阐述微服务架构下的安全认证与鉴权方案。

<!-- more -->

#### 单体应用 VS 微服务
- 单体应用体系下，应用是一个整体，一般针对所有的请求都会进行权限校验。请求一般会通过一个权限的拦截器进行权限的校验，在登录时将用户信息缓存到 session 中，后续访问则从缓存中获取用户信息。
- 微服务架构下，一个应用会被拆分成若干个微应用，每个微应用都需要对访问进行鉴权，每个微应用都需要明确当前访问用户以及其权限。尤其当访问来源不只是浏览器，还包括其他服务的调用时，单体应用架构下的鉴权方式就不是特别合适了。在为服务架构下，要考虑外部应用接入的场景、用户 - 服务的鉴权、服务 - 服务的鉴权等多种鉴权场景。
David Borsos 在伦敦的微服务大会上提出了四种方案：
1. **单点登录（SSO）**, 这种方案意味着每个面向用户的服务都必须与认证服务交互，这会产生大量非常琐碎的网络流量和重复的工作，当动辄数十个微应用时，这种方案的弊端会更加明显。
2. **分布式 Session 方案**, 分布式会话方案原理主要是将关于用户认证的信息存储在共享存储中，且通常由用户会话作为 key 来实现的简单分布式哈希映射。当用户访问微服务时，用户数据可以从共享存储中获取。在某些场景下，这种方案很不错，用户登录状态是不透明的。同时也是一个高可用且可扩展的解决方案。这种方案的缺点在于共享存储需要一定保护机制，因此需要通过安全链接来访问，这时解决方案的实现就通常具有相当高的复杂性了。
3. **客户端 Token 方案**, 令牌在客户端生成，由身份验证服务进行签名，并且必须包含足够的信息，以便可以在所有微服务中建立用户身份。令牌会附加到每个请求上，为微服务提供用户身份验证，这种解决方案的安全性相对较好，但身份验证注销是一个大问题，缓解这种情况的方法可以使用短期令牌和频繁检查认证服务等。对于客户端令牌的编码方案，Borsos 更喜欢使用 JSON Web Tokens（JWT），它足够简单且库支持程度也比较好。
4. **客户端 Token 与 API 网关结合**, 这个方案意味着所有请求都通过网关，从而有效地隐藏了微服务。在请求时，网关将原始用户令牌转换为内部会话 ID 令牌。在这种情况下，注销就不是问题，因为网关可以在注销时撤销用户的令牌。

#### 基于`Session`的认证
- 基于`Session`的认证应该是最常用的一种认证机制了。用户登录认证成功后，将用户相关数据存储到`Session`中，单体应用架构中，默认`Session`会存储在应用服务器中，并且将`Session ID`返回到客户端，存储在浏览器的`Cookie`中。
- 但是在分布式架构下，`Session`存放于某个具体的应用服务器中自然就无法满足使用了，简单的可以通过`Session`复制或者`Session`粘制的方案来解决。
- `Session`复制依赖于应用服务器，需要应用服务器有`Session`复制能力，不过现在大部分应用服务器如`Tomcat`、`JBoss`、`WebSphere`等都已经提供了这个能力。
- 除此之外，`Session`复制的一大缺陷在于当节点数比较多时，大量的`Session`数据复制会占用较多网络资源。`Session`粘滞是通过负载均衡器，将统一用户的请求都分发到固定的服务器节点上，这样就保证了对某一用户而言，`Session`数据始终是正确的。不过这种方案依赖于负载均衡器，并且只能满足水平扩展的集群场景，无法满足应用分割后的分布式场景。
- 在微服务架构下，每个微服务拆分的粒度会很细，并且不只有用户和微服务打交道，更多还有微服务间的调用。这个时候上述两个方案都无法满足，就要求必须要将`Session`从应用服务器中剥离出来，存放在外部进行集中管理。可以是数据库，也可以是分布式缓存，如`Memchached`、`Redis`等。这正是David Borsos建议的第二种方案，分布式`Session`方案。

#### 基于`Token`的认证
随着`Restful API`、微服务的兴起，基于`Token`的认证现在已经越来越普遍。`Token`和`Session ID`不同，并非只是一个`key`。`Token`一般会包含用户的相关信息，通过验证`Token`就可以完成身份校验。像`Twitter、微信、QQ、GitHub`等公有服务的`API`都是基于这种方式进行认证的，一些开发框架如`OpenStack、Kubernetes`内部`API`调用也是基于`Token`的认证。基于`Token`认证的一个典型流程如下:

- 用户输入登录信息（或者调用`Token`接口，传入用户信息），发送到身份认证服务进行认证（身份认证服务可以和服务端在一起，也可以分离，看微服务拆分情况了）。
- 身份验证服务验证登录信息是否正确，返回接口（一般接口中会包含用户基础信息、权限范围、有效时间等信息），客户端存储接口，可以存储在`Session`或者数据库中。
- 用户将`Token`放在`HTTP`请求头中，发起相关`API`调用。
- 被调用的微服务，验证`Token`权限。
- 服务端返回相关资源和数据

#### 基于 Token 认证的好处如下：

- 服务端无状态：`Token`机制在服务端不需要存储`session`信息，因为`Token`自身包含了所有用户的相关信息。
- 性能较好，因为在验证`Token`时不用再去访问数据库或者远程服务进行权限校验，自然可以提升不少性能。
- 支持移动设备。
- 支持跨程序调用，`Cookie`是不允许垮域访问的，而`Token`则不存在这个问题

#### 关于`Token`注销：
`Token`的注销，由于`Token`不存储在服务端，由客户端存储，当用户注销时，`Token`的有效时间还没有到，还是有效的。所以如何在用户注销登录时让`Token`注销是一个要关注的点。一般有如下几种方式：

- `Token`存储在`Cookie`中，这样客户端注销时，自然可以清空掉
- 注销时，将`Token `存放到分布式缓存中，每次校验`Token`时区检查下该`Token`是否已注销。不过这样也就失去了快速校验`Token`的优点。
- 多采用短期令牌，比如令牌有效期是`20 `分钟，这样可以一定程度上降低注销后`Token`可用性的风险