---
title: 登陆相关的知识
date: 2021-03-09 19:37:38
tags:
- JS
- Java
categories:
- 前端
- Java
---

### 简介

今天，我们来聊聊前端登陆相关的技术

<!-- more -->

### Session

会话（session）是一种持久网络协议，在用户（或用户代理）端和服务器端之间创建关联，从而起到交换数据包的作用机制，session在网络协议（例如telnet或FTP）中是非常重要的部分。
在不包含会话层（例如UDP）或者是无法长时间驻留会话层（例如HTTP）的传输协议中，会话的维持需要依靠在传输数据中的高级别程序。例如，在浏览器和远程主机之间的HTTP传输中，HTTP cookie就会被用来包含一些相关的信息，例如session ID，参数和权限信息等。
那么http是有状态的么？很明显是无状态的.
http协议是无状态的，每一次请求都无状态。当一个用户通过用户名和密码登录了之后，他的下一个请求不会携带任何状态，应用程序无法知道他的身份，那就必须重新认证。因此我们希望用户登录成功之后的每一次http请求，都能够保存他的登录状态

基于session的认证流程:

1. 用户输入其登录信息
2. 服务器验证信息是否正确，并创建一个session，然后将其存储在数据库中
3. 服务器为用户生成一个sessionId，将具有sesssionId的Cookie将放置在用户浏览器中
4. 在后续请求中，会根据数据库验证sessionID，如果有效，则接受请求
5. 一旦用户注销应用程序，会话将在客户端和服务器端都被销毁

基于session的认证过程，除了提交表单，其他基本没前端什么事。
这个时期的session都是保存在本地的web服务器内存中，非常简单就能保持用户状态。
随着业务的复杂度升高，和对应用性能、高可用的需求，系统演变成了集群和分布式架构

### 分布式架构下的Session管理

#### 复制

这个方案本质是利用了应用服务器自身的特性，如：tomcat。修改一下tomcat的配置文件，就是让应用服务器之间进行session复制，这样就可以达到每个服务器都有一样的session。

这个方案2-3个服务器还行，但服务器一旦多起来，就会有问题。
1. session之间的复制就会占用很大的网络带宽
2. session复制是有时间延迟的
3. 服务器的内存是有限的，代表着session存放是有限的

#### 粘性

这个方案就利用负载均衡器的特性，把同一个浏览器的同一个用户都定向发送到同一个服务器上。
用户甲访问系统被负载均衡器一直分配到服务器A上，这样也就保证了用户一直在同一个服务器中进行查找session，保证了用户session一致性。

不过此方案也存在一些问题：
1. 服务器的内存是有限的，代表着session存放是有限的
2. 这个方案适用集群架构，但不适用分布式架构
3. 一旦服务器拓展数量，session就会出现混乱

#### 外部存储

之前的服务器端改造的方案，session都是存储到本地内存中的，导致一些问题。 此外部存储就是把思路进行改变，让session的存储与应用服务器隔离出来

这个方案的核心就是把session的存储的地方改造到一个独立的媒介中，这样就不需要和应用服务器耦合了，客户端传入sessionId时，用户信息的映射关系直接到这个独立媒介中去查找。
redis存储方案一般结合spring session方式，把session存储到redis中
这个方案是spring提供的一套Session管理方案，通过一个SessionFilter将所有请求拦截下来，对session进行管理，此方案的好处就是不与应用服务器耦合，可以部署到任何web应用服务器中。redis也是高性能的缓存服务器，且可持久化。这个方案也是官方推荐的


### 第三方登陆

通过qq、微博、其他第三方登陆渠道，登陆网站

#### 原理

所谓第三方登录，实质就是 OAuth 授权。用户想要登录 A 网站，A 网站让用户提供第三方网站的数据，证明自己的身份。获取第三方网站的身份数据，就需要 OAuth 授权。
举例来说，A 网站允许 GitHub 登录，背后就是下面的流程:
1. A 网站让用户跳转到 GitHub。
2. GitHub 要求用户登录，然后询问"A 网站要求获得 xx 权限，你是否同意？"
3. 用户同意，GitHub 就会重定向回 A 网站，同时发回一个授权码。
4. A 网站使用授权码，向 GitHub 请求令牌。
5. GitHub 返回令牌.
6. A 网站使用令牌，向 GitHub 请求用户数据。

#### 授权应用登记

一个应用要求 OAuth 授权，必须先到对方网站登记，让对方知道是谁在请求。
所以，你要先去 GitHub 登记一下。当然，我已经登记过了，你使用我的登记信息也可以，但为了完整走一遍流程，还是建议大家自己登记。这是免费的。
访问这个网址，填写登记表。

### 联邦认证

在互联网早期，你的各类账号信息分散在不同的站点和应用，这存在以下问题：

每次访问一个新的站点都要注册一个新的用户名和密码账号。
这个账户就仅仅被存储在这个站点。
你无法在不同的站点下保持登录，用户的信息在不同的站点间也无法互通。
联邦认证通过标准协议将不同的身份提供商联合起来对用户进行认证。联邦是一种身份提供商之间的信任关系，建立联邦关系的身份提供商之间可以通过标准协议互相拉取用户信息。

#### 为什么需要联邦认证

联邦认证是一种分布式的身份认证，当用户在身份提供商登录时，用户可以选择到当前身份提供商信任的联邦身份提供商登录。用户可以通过联邦认证登录一个新的系统，而不必每次在新的系统中注册账号。例如现在许多网站有自己的账密注册登录方式，也有微信扫码直接登录的方式，其中的微信就是这个网站的身份联邦，用户不必填写信息注册账号，直接使用微信就可以登录。
使用联邦认证有以下好处：

1. 用户不必每次都要创建一个全新的账号。
2. 接入联邦认证后用户可以在不同的组织和站点中畅游。

联邦认证的种类:

- OAuth2.0
- OIDC
- SAML2
- CAS

#### OAuth 2.0
OAuth 2.0 是一个授权标准协议。如果你希望将自己应用的数据安全地授权给调用方，建议使用 OAuth 2.0。

根据 OAuth 2.0 协议规范，主要有四个主体：
- **授权服务器**，负责颁发 Access Token，Authing 是授权服务器。
- **资源所有者**，你的应用的用户是资源的所有者，授权其他人访问他的资源。
- **调用方**，调用方请求获取 Access Token，经过用户授权后，Authing 为其颁发 Access Token。调用方可以携带 Access Token 到资源服务器访问用户的资源。
- **资源服务器**，接受 Access Token，然后验证它的被赋予的权限项目，最后返回资源。

其他重要概念：
1. 一次 OAuth 2.0 授权是指用户授权调用方相关的权限。
2. Code 授权码是由授权服务器 Authing 颁发的，用于调用方使用 Code 换取 Token。
3. Access Token 由授权服务器 Authing 颁发，持有 Access Token 说明完成了用户授权。
4. Refresh Token 是一个可选的 Token，用于在 Access Token 过期后获取一个新的 Access Token。

####  OIDC
OpenID Connect 是基于 OAuth 2.0 的身份认证协议，增加了 Id Token。OIDC 也制定了 OAuth 2.0 中未定义部分的规范，例如 scope，服务发现，用户信息字段等。

在 OIDC 规范中，有些名词与 OAuth 2.0 有区别：

1. OpenID Provider，指授权服务器，负责签发 Id Token。Authing 是 OpenID Provider。
2. 终端用户，Id Token 的信息中会包含终端用户的信息。
3. 调用方，请求 Id Token 的应用。
4. Id Token 由 OpenID Provider 颁发，包含关于终端用户的信息字段。
5. Claim 指终端用户信息字段。
OIDC 的授权流程与 OAuth 2.0 一样，主要区别在于 OIDC 授权流程中会额外返回 Id Token

#### OIDC与OAuth2.0的比较

1. OAuth 2.0 协议主要用于资源授权。
2. OpenID Connect 协议，简称 OIDC，是 OAuth 2.0 协议的超集，能够认证用户并完成资源授权。在可以选择 OIDC 的情况下，应该选择 OIDC

### 认证与授权

在开发或者管理一个应用程序的时候，我们往往会看到两个名词——认证和授权，在英文中这两个词更为相近 —— authentication 和 authorization。尽管这两个属于经常出现在相同的上下文中，但是两者在概念上是非常不同的。
认证意味着确认你自己的身份，而授权意味着授予对系统的访问权限。简单来说，认证是验证你的身份的过程，而授权是验证你有权访问的过程。

#### 什么是认证

认证是关于验证你的凭据，如用户名/邮箱和密码，以验证访问者的身份。系统确定你是否就是你所说的使用凭据。在公共和专用网络中，系统通过登录密码验证用户身份。身份认证通常通过用户名和密码完成，有时与认证可以不仅仅通过密码的形式，也可以通过手机验证码或者生物特征等其他因素。
用户认证，指的是验证用户的身份，例如你希望以小A的身份登录，那么应用程序需要通过用户名和密码确认你真的是小A。

#### 什么是授权

授权发生在系统完成身份认证之后，最终会授予你访问资源（如信息，文件，数据库，资金，位置，几乎任何内容）的完全权限。简单来说，授权决定了你访问系统的能力以及达到的程度。
授权是确定经过身份验证的用户是否可以访问特定资源的过程。它验证你是否有权授予你访问信息，数据库，文件等资源的权限。授权通常在验证后确认你的权限。简单来说，就像给予某人官方许可做某事或任何事情。

|  认证	 |  授权  |
| ---  |  ---  |
|  验证确认身份以授予对系统的访问权限。	|  授权确定你是否有权访问资源。  |
|  这是验证用户凭据以获得用户访问权限的过程。	|  这是验证是否允许访问的过程。  |
|  它决定用户是否是他声称的用户。	|  它确定用户可以访问和不访问的内容。  |
|  身份验证通常需要用户名和密码。	|  授权所需的身份验证因素可能有所不同，具体取决于安全级别。  |
|  身份验证是授权的第一步，因此始终是第一步。	|  授权在成功验证后完成。  |
|  例如，特定大学的学生在访问大学官方网站的学生链接之前需要进行身份验证。这称为身份验证。	|  例如，授权确定成功验证后学生有权在大学网站上访问哪些信息。  |

### SSO 单点登陆

单点登录（Single Sign On），简称为 SSO，是比较流行的企业业务整合的解决方案之一。SSO 的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。

Google宣布禁用第三方cookie，有些使用第三方cookie来实现sso单点登陆的，需要使用1方cookie(cookie存放到主域名下)来实现。

### JWT

一个jwt实际上就是一个字符串，它由三部分组成，头部、载荷与签名，这三个部分都是json格式。

#### 头部（Header）

头部用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。
```json
  {
    "typ": "JWT",
    "alg": "HS256"
  }
```
在这里，我们说明了这是一个JWT，并且我们所用的签名算法是HS256算法。

#### 载荷（Payload）

载荷可以用来放一些不敏感的信息
```json
  {
    "iss": "John Wu JWT",
    "iat": 1441593502,
    "exp": 1441594722,
    "aud": "www.example.com",
    "sub": "jrocket@example.com",
    "from_user": "B",
    "target_user": "A"
  }
```
复制代码
这里面的前五个字段都是由JWT的标准所定义的。

- `iss`: 该JWT的签发者
- `sub`: 该JWT所面向的用户
- `aud`: 接收该JWT的一方
- `exp(expires)`: 什么时候过期，这里是一个Unix时间戳
- `iat(issued at)`: 在什么时候签发的
把头部和载荷分别进行Base64编码之后得到两个字符串，然后再将这两个编码后的字符串用英文句号.连接在一起（头部在前），形成新的字符串.
```js
// eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0
```
#### 签名（signature）
最后，我们将上面拼接完的字符串用HS256算法进行加密。在加密的时候，我们还需要提供一个密钥（secret）。加密后的内容也是一个字符串，最后这个字符串就是签名，把这个签名拼接在刚才的字符串后面就能得到完整的jwt。header部分和payload部分如果被篡改，由于篡改者不知道密钥是什么，也无法生成新的signature部分，服务端也就无法通过，在jwt中，消息体是透明的，使用签名可以保证消息不被篡改。
```js
// eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0.rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM
```

#### jwt的优点：
1. 可扩展性好, 应用程序分布式部署的情况下，session需要做多机数据共享，通常可以存在数据库或者redis里面。而jwt不需要。
2. 无状态, jwt不在服务端存储任何状态。RESTful API的原则之一是无状态，发出请求时，总会返回带有参数的响应，不会产生附加影响。用户的认证状态引入这种附加影响，这破坏了这一原则。另外jwt的载荷中可以存储一些常用信息，用于交换信息，有效地使用 JWT，可以降低服务器查询数据库的次数。

#### jwt的缺点：
1. 安全性, 由于jwt的payload是使用base64编码的，并没有加密，因此jwt中不能存储敏感数据。而session的信息是存在服务端的，相对来说更安全。
2. 性能, jwt太长。由于是无状态使用JWT，所有的数据都被放到JWT里，如果还要进行一些数据交换，那载荷会更大，经过编码之后导致jwt非常长，cookie的限制大小一般是4k，cookie很可能放不下，所以jwt一般放在local storage里面。并且用户在系统中的每一次http请求都会把jwt携带在Header里面，http请求的Header可能比Body还要大。而sessionId只是很短的一个字符串，因此使用jwt的http请求比使用session的开销大得多。
3. 一次性, 无状态是jwt的特点，但也导致了这个问题，jwt是一次性的。想修改里面的内容，就必须签发一个新的jwt。


（1）无法废弃
通过上面jwt的验证机制可以看出来，一旦签发一个jwt，在到期之前就会始终有效，无法中途废弃。例如你在payload中存储了一些信息，当信息需要更新时，则重新签发一个jwt，但是由于旧的jwt还没过期，拿着这个旧的jwt依旧可以登录，那登录后服务端从jwt中拿到的信息就是过时的。为了解决这个问题，我们就需要在服务端部署额外的逻辑，例如设置一个黑名单，一旦签发了新的jwt，那么旧的就加入黑名单（比如存到redis里面），避免被再次使用。
（2）续签
如果你使用jwt做会话管理，传统的cookie续签方案一般都是框架自带的，session有效期30分钟，30分钟内如果有访问，有效期被刷新至30分钟。一样的道理，要改变jwt的有效时间，就要签发新的jwt。最简单的一种方式是每次请求刷新jwt，即每个http请求都返回一个新的jwt。这个方法不仅暴力不优雅，而且每次请求都要做jwt的加密解密，会带来性能问题。另一种方法是在redis中单独为每个jwt设置过期时间，每次访问时刷新jwt的过期时间。